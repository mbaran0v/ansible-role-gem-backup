#!/usr/bin/env ruby
# {{ ansible_managed }}

{% set model_name = item.name %}
{% set model_label = item.label|d("Backup " + ansible_hostname) %}
##
# $ backup perform -t {{ model_name }} [-c <path_to_configuration_file>]
#
Model.new(:{{ model_name }}, "{{ model_label }}") do

{% if item.before_hook | d("") %}
before do |model|
    {{ item.before_hook | indent(4) }}
end
{% endif %}

{% for model_db in item.databases | d([]) %}
{% for dbs in gem_backup_databases %}
{% if dbs.name == model_db %}
{% if dbs.type == 'mysql' %}
  ##
  # MySQL [Database]
  #
  database MySQL, :"{{ dbs.name }}" do |db|
    # To dump all databases, set `db.name = :all` (or leave blank)
    {% if dbs.db is defined %}
    db.name               = "{{ dbs.db }}"
    {% else %}
    db.name               = :all
    {% endif %}
    db.username           = "{{ dbs.username }}"
{% if dbs.password is defined %}
    db.password           = "{{ dbs.password }}"
{% endif %}
    db.host               = "{{ dbs.host | d('127.0.0.1') }}"
    db.port               = {{ dbs.port | d(3306) }}
{% if dbs.socket is defined %}
    db.socket             = "{{ dbs.socket }}"
{% endif %}
    # Note: when using `skip_tables` with the `db.name = :all` option,
    # table names should be prefixed with a database name.
    # e.g. ["db_name.table_to_skip", ...]
    db.skip_tables        = []
    db.only_tables        = []
    db.additional_options = {{ dbs.options | d([]) }}
  end
{% endif %}
{% if dbs.type == 'postgresql' %}
  ##
  # PostgreSQL [Database]
  #
  database PostgreSQL, ":{{ dbs.name }}" do |db|
    # To dump all databases, set `db.name = :all` (or leave blank)
    {% if dbs.db is defined %}
    db.name               = "{{ dbs.db }}"
    {% else %}
    db.name               = :all
    {% endif %}
    db.username           = "{{ dbs.username | d('postgres') }}"
{% if dbs.password is defined %}
    db.password           = "{{ dbs.password }}"
{% endif %}
    db.host               = "{{ dbs.host | d('127.0.0.1') }}"
    db.port               = {{ dbs.port | d(5432) }}
{% if dbs.socket is defined %}
    db.socket             = "{{ dbs.socket }}"
{% endif %}
    # When dumping all databases, `skip_tables` and `only_tables` are ignored.
    db.skip_tables        = []
    db.only_tables        = []
    db.additional_options = {{ dbs.options | d([]) }}
  end
{% endif %}
{% if dbs.type == 'ldap' %}
  ##
  # OpenLDAP [Database]
  #
  database OpenLDAP, :"{{ dbs.name }}" do |db|
    db.name               = "{{ dbs.db }}"
    db.slapcat_conf       = "{{ db.slapcat_conf_dir }}"
    db.slapcat_args       = {{ db.slapcat_args | d([]) }}
  end
{% endif %}
{% if dbs.type == 'mongodb' %}
  ##
  # MongoDB [Database]
  #
  database MongoDB, ":{{ dbs.name }}" do |db|
    db.name               = "{{ dbs.db }}"
    db.username           = "{{ dbs.username }}"
    db.password           = "{{ dbs.password }}"
{% if dbs.authdb is defined %}
    db.authdb             = "{{ dbs.authdb }}"
{% endif %}
    db.host               = "{{ dbs.host | d('127.0.0.1') }}"
    db.port               = {{ dbs.port | d(27017) }}
    db.ipv6               = false
{% if dbs.only_collections is defined %}
    db.only_collections   = {{ dbs.only_collections }}
{% endif %}
    db.additional_options = {{ dbs.additional_options | d([]) }}
    db.lock               = {{ dbs.lock | d('false') }}
    db.oplog              = {{ dbs.oplog | d('false') }}
  end
{% endif %}
{% endif %}
{% endfor %}
{% endfor %}

{% for model_files in item.files | d([]) %}
{% for f in gem_backup_files %}
{% if f.name == model_files %}
  ##
  # Archive files [Archive]
  #
  archive :"{{ f.name }}" do |archive|
    archive.tar_options '{{ f.tar_options | d("-p") }}'
{% for item in f.add %}
    archive.add '{{ item }}'
{% endfor %}
{% if f.exclude is defined %}
{% for item in f.exclude %}
    archive.exclude '{{ item }}'
{% endfor %}
{% endif %}
  end
{% endif %}
{% endfor %}
{% endfor %}


{% for model_stor in item.storages %}
{% for stor in gem_backup_storages %}
{% if stor.name == model_stor %}
{% if stor.type == 's3' %}
  ##
  # Amazon Simple Storage Service [Storage]
  #
  store_with S3 do |s3|
    # AWS Credentials
    s3.access_key_id     = "{{ stor.access_key }}"
    s3.secret_access_key = "{{ stor.secret_access_key }}"
    s3.region            = "{{ stor.region|default('us-east-1') }}"
    s3.bucket            = "{{ stor.bucket }}"
    s3.path              = "{{ stor.path|default('') }}"
    s3.keep              = {{ stor.keep|default(14) }}
    s3.max_retries       = {{ stor.max_retries|default(10) }}
    s3.retry_waitsec     = {{ stor.retry_waitsec|default(30) }}
{% if stor.fog_options is defined %}
    s3.fog_options = {
    {% for k, v in stor.fog_options.items() %}
        {{ k }}: {{ v | lower }},
    {% endfor %}
    }
{% endif %}
  end
{% endif %}
{% if stor.type == 'scp' or stor.type == 'sftp' %}
  ##
  # SCP/SFTP (Secure Copy) [Storage]
  #
  store_with {{ stor.type| upper }} do |server|
    server.username   = "{{ stor.username }}"
{% if stor.password is defined %}
    server.password   = "{{ stor.password }}"
{% endif %}
    server.ip         = "{{ stor.host }}"
    server.port       = "{{ stor.port|default(22) }}"
    server.path       = "{{ stor.path }}"
    server.keep       = {{ stor.keep|default(14) }}
    # Additional options for the SSH connection.
    server.ssh_options = {{ stor.ssh_options|d({}) }}
  end
{% endif %}
{% if stor.type == 'ftp' %}
  ##
  # FTP [Storage]
  #
  store_with FTP do |server|
    server.username   = "{{ stor.username }}"
    server.password   = "{{ stor.password }}"
    server.ip         = "{{ stor.host }}"
    server.port       = "{{ stor.port | d(21) }}"
    server.path       = "{{ stor.path }}"
    server.keep       = {{ stor.keep | d(14) }}
    server.passive_mode = {{ stor.passive_mode | d('false') | lower }}
    # Configures open_timeout and read_timeout for Net::FTP
    server.timeout      = {{ stor.timeout | d(10) }}
  end
{% endif %}
{% if stor.type == 'local' %}
  ##
  # Local (Copy) [Storage]
  #
  store_with Local do |local|
    local.path       = "{{ stor.path }}"
    local.keep       = {{ stor.keep | d(14) }}
  end
{% endif %}
{% endif %}
{% endfor %}
{% endfor %}

{% if gem_backup_encryptors %}
  ##
  # OpenSSL [Encryptor]
  #
  encrypt_with OpenSSL do |encryption|
{% if gem_backup_encryptors.password is defined %}
    encryption.password      = "{{ gem_backup_encryptors.password }}"
{% else %}
    encryption.password_file = "{{ gem_backup_encryptors.password_file }}"
{% endif %}
    encryption.base64        = true
    encryption.salt          = true
    # to decrypt, use the following command:
    # openssl aes-256-cbc -d -base64 -in my_backup.tar.enc -out my_backup.tar
  end
{% endif %}

{% if gem_backup_compressors %}
{% if gem_backup_compressors.type == 'gzip' %}
  ##
  # Gzip [Compressor]
  #
  compress_with Gzip do |compression|
    compression.level = {{ gem_backup_compressors.level | d(6) }}
    compression.rsyncable = true
  end
{% endif %}
{% if gem_backup_compressors.type == 'bzip2' %}
  ##
  # Bzip2 [Compressor]
  #
  compress_with Bzip2 do |compression|
    compression.level = {{ gem_backup_compressors.level | d(9) }}
  end
{% endif %}
{% endif %}

{% for model_notify in item.notifiers | d([]) %}
{% for notty in gem_backup_notifiers %}
{% if notty.name == model_notify %}
{% if notty.type == 'mail' %}
  ##
  # Mail [Notifier]
  #
  notify_by Mail do |mail|
    mail.on_success           = {{ notty.on_success | d('true') | lower }}
    mail.on_warning           = {{ notty.on_warning | d('true') | lower }}
    mail.on_failure           = {{ notty.on_failure | d('true') | lower }}

    mail.from                 = "{{ notty.from }}"
    mail.to                   = "{{ notty.to }}"
{% if notty.cc is defined %}
   mail.cc                   = "{{ notty.cc }}"
{% endif %}
{% if notty.bcc is defined %}
   mail.bcc                  = "{{ notty.bcc }}"
{% endif %}
{% if notty.reply_to is defined %}
    mail.reply_to             = "{{ notty.reply_to }}"
{% endif %}
    mail.address              = "{{ notty.address }}"
    mail.port                 = {{ notty.port | d(25) }}
{% if notty.domain is defined %}
    mail.domain               = "{{ notty.domain }}"
{% endif %}
{% if notty.username is defined %}
    mail.user_name            = "{{ notty.username }}"
{% endif %}
{% if notty.password is defined %}
    mail.password             = "{{ notty.password }}"
{% endif %}
{% if notty.authentication is defined %}
    mail.authentication       = "{{ notty.authentication }}"
{% endif %}
    mail.encryption           = {{ notty.encryption | d(':none') }}
{% if notty.openssl_verify_mode is defined %}
   mail.openssl_verify_mode   = "{{ notty.openssl_verify_mode }}"
{% endif %}
  end
{% endif %}
{% if notty.type == 'http_post' %}
  ##
  # HttpPost [Notifier]
  #
  notify_by HttpPost do |post|
    post.on_success = {{ notty.on_success | d('true') | lower }}
    post.on_warning = {{ notty.on_success | d('true') | lower }}
    post.on_failure = {{ notty.on_success | d('true') | lower }}

    # URI to post the notification to.
    # Port may be specified if needed.
    # If Basic Authentication is required, supply user:pass.
    post.uri = '{{ notty.uri }}'

    ##
    # Optional
    #
    # Additional headers to send.
    # post.headers = { 'Authentication' => 'my_auth_info' }
    #
    # Additional form params to post.
    # post.params = { 'auth_token' => 'my_token' }
    #
    # Successful response codes. Default: 200
    # post.success_codes = [200, 201, 204]
    #
    # Defaults to true on most systems.
    # Force with +true+, disable with +false+
    # post.ssl_verify_peer = false
    #
    # Supplied by default. Override with a custom 'cacert.pem' file.
    # post.ssl_ca_file = '/my/cacert.pem'
  end
{% endif %}
{% if notty.type == 'slack' %}
  ##
  # Slack [Notifier]
  #
  notify_by Slack do |slack|
    slack.on_success = {{ notty.on_success | d('true') | lower }}
    slack.on_warning = {{ notty.on_success | d('true') | lower }}
    slack.on_failure = {{ notty.on_success | d('true') | lower }}

    # The incoming webhook url
    # https://hooks.slack.com/services/xxxxxxxx/xxxxxxxxx/xxxxxxxxxx
    slack.webhook_url = '{{ notty.url }}'

    ##
    # Optional
    #
    # The channel to which messages will be sent
{% if notty.channel is defined %}
    slack.channel = '{{ notty.channel }}'
{% endif %}
    #
    # The username to display along with the notification
{% if notty.username is defined %}
    slack.username = '{{ notty.username }}'
{% endif %}
  end
{% endif %}
{% if notty.type == 'command' %}
  notify_by Command do |cmd|
    cmd.on_success = {{ notty.on_success | d('true') | lower }}
    cmd.on_warning = {{ notty.on_warning | d('true') | lower }}
    cmd.on_failure = {{ notty.on_failure | d('true') | lower }}

    cmd.command = '{{ notty.cmd }}'

    cmd.args = {{ notty.args|default('["Backup %l", "%v"]') }}
  end
{% endif %}
{% endif %}
{% endfor %}
{% endfor %}

{% if item.after_hook | d("") %}
after do |model|
    {{ item.after_hook | indent(4) }}
end
{% endif %}

end
